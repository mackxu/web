<script>
// 使用策略模式设计奖金
var calculateBonus = function(performanceLevel, salary) {
	if(performanceLevel === 'S') {
		return salary * 4;
	}

	if(performanceLevel === 'A') {
		return salary * 3;
	}

	if(performanceLevel === 'B') {
		return salary * 2;
	}
};

var s = calculateBonus('S', 40000);				// 160000
var b = calculateBonus('B', 10000);				// 20000
console.log(s, b);
// 使用组合函数重构代码
var performanceS = function(salary) { return salary * 4; };
var performanceA = function(salary) { return salary * 3; };
var performanceB = function(salary) { return salary * 2; };

var calculateBonus = function(performanceLevel, salary) {
	if(performanceLevel === 'S') {
		return performanceS(salary);
	}

	if(performanceLevel === 'A') {
		return performanceA(salary);
	}

	if(performanceLevel === 'B') {
		return performanceB(salary);
	}
};

var ss = calculateBonus('S', 20000);			// 80000
var bb = calculateBonus('B', 5000);				// 10000
console.log(ss, bb);

// 使用策略模式重构代码
// 策略模式定义: 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换
var strategies = {
	S: function(salary) {
		return salary * 4;
	},
	A: function(salary) {
		return salary * 3;
	},
	B: function(salary) {
		return salary * 2;
	},
};

var calculateBonus = function(level, salary) {
	return strategies[level].call(this, salary);
};

var sss = calculateBonus('S', 2000);				// 8000
var bbb = calculateBonus('B', 500);					// 1000
console.log(sss, bbb);
</script>